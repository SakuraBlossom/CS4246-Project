System for solving the game "The Minesweeper" by using Bayesian networks
Artificial Intelligence - Course 2017/2018



Miguel Angel Antolin Bermudez University of Seville
Seville, Spain migantber@alum.us.es


Sumari Using a Bayesian network to determine with inference
Probably the existence of a mine in a square after each move.
Keywords— board, squares, mine, game, probability, network
tkey words)
INTRODUCTION
"The Minesweeper" (Minesweeper), is a video game for a player invented by Robert Donner
in 1989. The object of the game is to clear a minefield without detonating any. On
  The game is based on a grid of known dimensions in which there are
hiding a predetermined number of mines. In each play, one of
the boxes. If the discovered square contains a mine, the game is lost.
If the discovered space does not contain a mine, clear an area of ​​the
Grid up to the boxes that border any box that contains a

David de la Torre Diaz University of Seville Seville, Spain davdedia@alum.us.es


I will be building a Bayesian network generated by the Pgmpy [4] library that will
updating with the evidence of each of the boxes discovered in each movement.
mine. In the latter there is information about the
                                                            number of mines in the boxes
adjoining. In the

Figure 1 and Jgt / ra 2 you can see two screenshots of the game.
Board situation after discovering a mine. When the game is lost, the game is lost.
Given the exponential complexity of this algorithm, methods will be implemented and proposed for the
improved inference.


II. OBJECTIVE
Implement a method that builds the Bayesian network associated with a board
given, taking into account that this information will be necessary to build the
net.
Implementation of a method that determines the cells with the highest probability of not
contain a mine and suggest them as the next step in the game. For this I
describe the current situation of the
                                                                                                    
game using a Bayesian network, this mechanism
will use an exact inference system on the network

r Dashboard once done
e S S
h b '

discovered mine. The numbers contemplated da i ']' rno cyân 'obre mines
adjoining.


This document will describe the steps to be carried out to calculate, by means of
Probabilistic inference, the probability that each undiscovered square on the game board has
contain mine. All this i know
(elimination of variables) to deduce the probability that there is a mine in each one
of the squares on the board that are not discovered using as evidence the
information about the discovered squares on the board. The boxes will be suggested
most likely not to contain a mine.

Implement a mechanism that develops a complete game of the game, choosing in
 each step the box with the highest probability of not containing a mine. The result of
discovering said square (in case of not finishing the game) will be used as input to give the
next step.
Achieve fiptimo system performance for different dash configurations
from the situation obtained after the first play. These tests should include the
sizes with mines, with mines, with mines, with mines,
         with
with mines, with mines, with mines, with mines, with
  mines.

III. THE ROAD FINDER GAME
This document is not intended to create the game in st, so it is
 will make use of an implementation already made, "The Minesweeper" [i) made in
Python. However, some aspects of the
implementation of the same, with the aim of simplifying the understanding of this
document.


A. BOARD GENERATION

Given height (, width () and number of mines (num),
a board is created in the form of a matrix:

where


To generate the map of mines, a matrix of zeros is formed, the same size as the board,
by means of the Numpy package [2]. To add the bombs (convert some zeros
by ones), random permutations are performed and the values ​​of the
checked boxes. The values ​​of as many squares as number of mines will be substituted.
indicated in the initialization of the board.
This implementation provides a way to be able to check at any time of the game
the state of the board. This information is supplied through a matrix of size
equal to 1 board where in each square the information related to:


if x is checked
10 if x is unknown
11 if x is not discovered
12 if x is a mine
0 O i x i 8 if x none of the above

The map obtained will have different information contained in each iteration of the game,
as the player makes movements.

B. MOVEMENTS CONSIDERED

The author of the project contemplates a series of movements for the realization of the
play. Some of them will be mentioned later in this document.
All movements are defined by a position and to be able to
be manipulable:


to. Click !!!. ’Reveals the information of a box. If the selected box contains a
 mine, the game is over. If, on the other hand, the selected cell does not contain a mine,
 it will reveal that square and the adjacent map area, if applicable.

b. Flag: It places in the given position a visual identifier that helps the
player to make future decisions. This movement under no circumstances reveals
map information. The only objective of this move is to allow the player
subjectively determine the position of a potential mine.

c. Unfiag: Removes from a given position an identifier previously placed by
the player. This movement under no circumstances reveals information on the map. If the
 information of these boxes is revealed by a click movement, the identifier is
remove from that position.

d. Question: Put in the given position a visual identifier that helps
a1 player to make future decisions. This movement under no circumstances reveals
 map information. Unlike the Flag move, the player will make use of this
movement when unaware of the existence of a mine in the given square.



C. OTHER CONSIDERATIONS

Since the selected project is under the MIT license, which allows
modifications of the same, we have proceeded to eliminate or modify some functions of them.
Removed TCP connections and other function definitions that were not working
relevant to our task.

Code has been added to get information directly from the game and power
construct the network that will compute the inference. The implementation of this code is
will expose in the next sections.


IV. FROM THE BOARD TO THE BAYESIAN NETWORK
In the network that we will build, there are two types of random variables for each cell:

• Random variables associated with the presence of a mine in a square. These variables
are of the integer type, where the value 1 indicates the presence of the mine in the box, and the value 0
indicates that the box is free. All these variables are distributed in the same way and the
The probability that they take the value 1 will depend on the number of hidden mines and the number of
squares on the board. In the initial state serta:
In order to obtain the list of nodes that will make up the graph, which will contain the
known information about cells and their adjacency relationships with their
neighbors, we have followed the following steps:

to. Go through the board with two indices (one for each dimension) passing through all the
 cells, storing their position and creating a list with their adjacent cells:
named nodes = [] for from to
stop from to
Named nodes.add ("X")


b. Obtain the neighbors of a position by checking their relative position on the board,
since it is a condition of the number of neighbors of a box, being neighbors of a
checkbox all those that meet the following statements. "

to. For any central box.


• Random variables associated with the number of mines in the neighboring squares
(neighbors) to a box. These variables are of the discrete type and can take values ​​from up to
. In particular, the random variables Y associated with the corner boxes can only be
take values ​​from to, and
is left horizontal neighbor sii. is right horizontal neighbor sii. is vertical neighbor
up yes.
is vertical neighbor below sii.
is the left diagonal neighbor above sii. is_diagonal_neighbour_left_down yes. is a neighbor
right diagonal up sii. is right diagonal neighbor below sii.

b. For the corners. '
(z)

associated to the perimeter squares only
they can take values ​​from to. Each of these variables depends on the variables
adjoining. The probability that one of these variables takes a value will depend on the number of
neighboring variables containing a mine:

yes and tq $
0 otherwise


Furthermore, all combinations of the x-states of the parents of F have to meet the
following:



As already specified in the previous section, certain methods have been necessary
that provide us with information about the board in order to be able to obtain the probability
described above, in addition to the information needed to build the network
Bayesian with its corresponding graph and conditional probability tables (CPDs).
• If i = = # ^ y = = #, it is the upper left corner:
- is_horizontal_right_neighbour sit.
- is_vertical_neighbour_down sit.
- is_diagonal_neighbour_left_down sit.

• If i = = w-I ^ j - - 0, it is the upper right corner:
- is left horizontal neighbor sii.
- is vertical neighbor below sii.
- is right diagonal neighbor below sit.

• If (i —— —— w-1) ^ (j - - h-1), is the lower right corner:
- is vertical neighbor above sii.
- is right horizontal neighbor sii.
- is_neighbour_diagonal_left_up yes.

• If i = = # ^ (J = = h-1), it is the lower left corner:
- is vertical neighbor above sii.
- is left horizontal neighbor sii.
- is right diagonal neighbor above sii.

c. For the perimeter of the board.
• If i = = #, it is the left part of the perimeter of the board:
- is vertical neighbor above sii.
- is vertical neighbor below sii.
- is right horizontal neighbor sit.
- is neighbor_diagona1 right_up sit.
- is right_diagonal neighbor_down sit.

• If i = = ir- /, it is the right part of the perimeter of the board:
- is vertical neighbor above sii.
- is vertical neighbor below sii.

- is left horizontal neighbor sii.
- is_neighbour_diagonal_left_up yes.
- is_diagonal_left_neighbour_down yes.

• Siy = = #, it is the lower part of the perimeter of the board.
- is left horizontal neighbor sii.
- is right horizontal neighbor sii.
- is vertical neighbor below sii.
- is_diagonal_neighbour_left_down sit.
- is right diagonal neighbor below sii.


• Sij = = h-1, it is the upper part of the perimeter of the deck.
- is left horizontal neighbor sii.
- is right horizontal neighbor sii.
- is vertical neighbor above sii.
- is neighbor diagonal left above sii.
- is right diagonal neighbor above sii.


c. Given the neighbors of each square, we create a set with all the nodes and
the related edges, to be added later to the graph to be modeled. '
for from 0 to
stop from to
neighbors - osition neighbors for each neighbor x in neighbors.
graph.add (neighbors [], "AND")



d. We add to the Bayesian model the information obtained previously together with the
probability functions of O and to obtain the CPDS of the variable X, we use
of the initial probability given by the initial probability formula of the X seen
previously. From the result obtained we create a CPD for each X of the graph
assigning the corresponding values.

resX— [All X nodes] all resX.
cpcl XP - CPifresXfe], 2, f [prohahNoBomha, prohahBomha]])

model.add CPD (cpd X) OS


For the CPDs of the variable Y, we go through the list of cells, we obtain the neighbors of the
cell that is being iterated at that moment and permutations are made on the number
of neighbors and thus the probability of the number of mines in neighboring squares is calculated.
calculated probabilities. add (1) if not.
calculated probabilities. add (0)

joined probabilities.add (calculated probabilities)
cpd Y - CPD (box 1 to iterate from resY,
size neighbors) +1 united probabilities, neighbors, size (neighbors)

model.addCPD (cpd Y)

V. BOX SUGGESTION SYSTEM After the construction of our model
bayesian,
we design an algorithm that makes queries to this to obtain, after a movement
random on the board, a suggestion of the next move. Being this last one
 of the undiscovered squares adjacent to an island with a lower probability of
contain a bomb:
The first movement is carried out randomly, generating each of its indexes of the
 following form.
- randInt
- randInt

After knowing which is the selected box to click, and before making the move
click on that box, an algorithm has been developed that clears one area at least
of nine squares by moving the mines found to the corners or to the sides
of the board. This action is contemplated in the decompiled code of the
original minesweeper [3], so no "illegal" action is taking place. The
algorithm contemplates the following:


define move_mines_around (i, j). if board.MineMap [j, i] —— 1. ’
move mine to corner (j, i)
neighbors - neighbors deposition for all neighbors in neighbors.
i - position i of neighbor j - position j of neighbor
yes board. minemap [j, i] —— 1. move mine to corner (j, i)

define move mine to corner (x, i). '
resY [s for all named nodes if 'Y'

contained in
for all 1 values ​​of resY.




this

for all neighbor v values. computed probabilities - [] for all a values ​​of
resA.
list - resA [a]
counter counterPermutations (list) if counter is v.
if board.MineMapS [w-1, h-1] —— 0. board.MineMap fj, i]
board. minemap [w-1, h-1] - 1 if board.minemap [0, 0] —— 0.
board.MineMap [x, i—] 0 board.MineMap [0, 0] - 1
st board.MineMap [w- I, 0] —— 0. board.MineMap [x, i—] 0

board.MineMap [w-1, 0—] 1 yes board. minemap [0, h-1] —— 0:
board. minemap [x, i] - 0 board.minemap [0, h-1] 1



Once the mines have been placed in their new positions, they proceed to clear
a square by means of the click movement with the command:
game.play move ("click",,) S

After this movement, the state of the board changes and new evidence is obtained. This new
information would be used to calculate the next move as follows:
We iterate the game board again to observe the evidence discovered after the
movement performed:

for all i in width of the board. for all j in width of the board.
checkbox status - map information in (i, j) if checkbox status is between 0
and 8.
add evidence Xij - 0
add evidence Yij - checkbox state if checkbox state is 0. '
add evidence Xij 0 add evidence Yij 0
If state caSi / fa is 11.
add Yij to evidence list add Xij to undiscovered squares
if box state is 9. ’
add evidence Xij 1OS


Now we have to obtain those boxes that are susceptible to be consulted by their
probability of containing mine, these are; those undiscovered boxes that
are neighboring squares already discovered, that is, we obtain all the squares
adjoining an island. The selection of these specific boxes is due to the fact that these
The boxes are the ones that are still undiscovered, but they are the ones with the most useful information.
to be able to make a truthful and fast consultation.
The system will iterate each box of that set and perform the following operations
about them:
to. All those boxes that are neither for consultation nor for evidence and that also
are not leaves of the tree. It should be noted that the boxes that are eliminated vary in each
iteration of the set that we are traversing.
b. Once this is done, the VariableElimination method will be used to carry out
the consultation of said box.
c. To carry out the query, a new specific model is generated for the
elimination of
variables to which a query will be made passing as parameters the
box that we are consulting and a list with the evidences
related.

Model for elimination - pgmi.VariableElimination (model) query— Query Model for
  elimination given a
undiscovered box and a list of evidences.


d. Once the value corresponding to the probability of a mine existing in that
box and in order to optimize the algorithm, it passes through an established filter
previously (the choice of the filter is detailed in the section "increasing
 efficiency ") in which it is decided whether that box contains a bomb or not, e1
filter would be the following:


if l B (X j) • 790 P (XI j) otherwise


l if l & (X „j) B.90
R X
'’’ (X j In another case


As can be seen here, if a square has a probability greater than 0.90 of not
 contain a bomb, the loop will be broken and a click movement will be made on that
box going to the next query. Similarly, if that box has a
probability greater than 0'790 of containing a mine, it goes to the next iteration of the loop and
mark that square as a mine with the Flag move.
and. Finally, if none of the iterated elements has entered the condition of no
mine, among all of them, the one with the highest probability will be selected to click
 must not contain a mine. With equal probabilities, the first will be selected.

probabilities list
for all inquiries made.
Add query result to list rohahilidade.s
probabilities not mine - First elements of the list of probabilities.
suggests the index with the highest value from the list of probabilities of not containing a mine



SAW. INCREASING EFFICIENCY
In the scope of the problem, efficient is understood as that implementation that
be able to solve the larger 8x8 board with 25 mines

in less than an hour, making only use of a CPU core of at least 3Ghz speed of
clock and in no time the GPU.
Taking into account this premise and given the base implementation of the library
used, carry out the reso1ution action in the time described above.
makes it an impossible task since in 100% of the cases, the huge amount of
Used memory causes an overflow just several minutes after starting.
This overflow is mainly due to the lack of efficiency of the library
Pgmpy that far from trying to optimize the relevant variables in each query,
attempts to perform the variable removal algorithm in all cases with all
variables of the graph, whether or not it has evidence of them, whether or not they are leaves of the graph,
for instance:
There is a 5X5 board with 5 mines without any type of evidence, a
inquire about the probability of a random square. At this time the algorithm has
 take into account all the variables of the graph, that is, all the I's and all the Y's to give
 an answer that in theory should be instantaneous. Such an answer is found
exposed above and is calculated with the number of mines and the number of squares on the board.
What should take a few milliseconds, can take hours for not having
eliminated all irrelevant variables in the problem domain.
To carry out the correction of this problem, a series of
mechanisms that greatly improve the efficiency of the algorithm:
to. First, the algorithm is exempted from having to calculate the probabilities
initials of the X's making use of the formula that involves the number of boxes and the number
of mines.
b. Second, a method is implemented that in the first move of the game, in the 100%
 of the cases generate an island of a1 minus 9 elements ta1 and how was implementing
 in "The Minesweeper" original. This makes the algorithm always have a number
considerable evidence in the first movement
and. Fifth, a bound is established by which the existence of a
mine in a box, that is; After querying the probability of the
existence of a mine in a square, it is checked whether the resulting number is contained between the
dimension:
If the probability of existence of a mine exceeds this level, the system will mark
automatically said box as a mine and will go to the next one without it becoming a
candidate to click on in the next move. Similarly, if the number
obtained is below the level, the system will automatically interpret that in that
box does not exist a mine and it will click immediately, breaking the loop and
moving on to the next move.
The choice of the dimension is not trivial since a dimension of the non-existence of
Mine too low would increase the probability of clicking by mistake.
Similarly, the existence of a mine that is too low could cause
will mark a box that is not mine as mine.
After many checks, we have come to the conclusion that a dimension
as described above is at the midpoint between the phyptimus and
what is permissible when providing truthful results.
These described improvements make it possible to run a 10X10 board with 25
mines in an hour, which was previously impossible to solve given its size.

VII. TEST OF PERFORMANCE
For the performance tests of the Bayesian network, the time it takes for the
algorithm in suggesting a square and solving the board satisfactorily, opposite
the size of the board and the number of mines contained in it.
After carrying out several tests with the required sizes, the
following duration data:

i i
c. Third, to deduce the following "’ movement of the
game, the query is made to the "* squares adjacent to" an island and not to
all "’ "*” "hidden squares on the board, reducing by one big” '’‘ * "” ’‘
number the number of queries to be made "'"'
d. Fourth, in each of the iterations of the consulted cells, it is created
a submodel resulting from eliminating from the original model those

irrelevant variables for the query, that is, all variables that are neither
consultation or evidence, and also are leaves of the tree. What results from a model
much simpler and less complex.
Ma 3: Graph that relates each of the sizes in the test, duration of the complete resolution
of the board by the
algorithm together with the average line.

sure answer about the next move, or in the opposite case, a first click on it that
an island is generated with many uncovered squares and a lot of information about the
number of mines in the adjoining boxes would make our algorithm work and
provide more truthful and quick answers.

Total length


that each min ratio of /o.s sizes in the te.st2 duration of the re. ‹aluciân complete Jel
board for part of
juiito algorithm with the average line.







Figure 6. Cirâfica includes the duration of each of the tests of the tests carried out.





each of the sizes in the complete test3 of the board by the
algorithm together with the average line.
It can be seen in the three graphs that with small board sizes (5x5), the
complexity of the network is small, as there is a big difference in the
proportion number of evidences - number of boxes to discover, after a click on the
board reveals much of its content. The initial probability of finding
mines with 5, 6 and 7 mines are 0'2, 0'24 and 0'28 respectively. The resolution time up to
the victory for our inference algorithm is 1 minute.
With 8x8 size boards, complexity increases as there is a greater number of
squares on the board, but the pump ratio remains relatively stable since
 the initial probability of finding a mine with 13, 14 and 15 mines will be 0'20,
0'218, 0'234 respectively. The resolution time until victory is about 10 minutes.
For larger boards (10x10), the

If we calculate the average time of resolution of boards until the victory by
our network with all previously used sizes and variations obtained in
 the 3 tests, we have an average time of 23 minutes.









8 x 8 coil 1 fi M I NAS - • •
     •






1 0 x l (I cold 25 M INA S



Fi Graph that relates each type of size to the

initial probability of finding a mine for boards with 23, 24 and 25 mines are
  0'23, 0'24, 0'25 respectively, are figures similar to the previous ones, but with
this size of board, the resolution time until victory by part
of our
duration
del t bl t d l
el pro o to "and" el "mâxeltl
algorithm and the

inference algorithm comes to be around the hour.
However, measurements fluctuate greatly between boards of the same size with
equal number of pumps depending on the test case. This is because
chance greatly influences the final complexity and the time of
total resolution of the board, since the number of evidences after the first click
it conditions our board a lot.
A first click with little evidence would make our algorithm take longer to
  give us a
VIII. CONCLUSIONS
As has been seen, the game "Minesweeper" is a useful example
  how a Bayesian network can be used to solve a complex problem.
After searching for cfimo to be able to make an efficient query to the network, and after having
made a large number of possible simplifications to this, it is achieved r
bring the problem down to a moderately acceptable size for a
 contemporary machine, already

that Pgmpy performs a too exact calculation on the nodes of the network and there are
memory overflows during calculations, or simply due to having
a very large graph with a lot of information that has to be reduced to make a
inquire about it.
The utilities created to create islands of squares have been key after the first click of the game,
as it helps to rearrange the information about the mines on the board and that the player, or
In this case our algorithm, have much more information at the beginning of the game to
 to be able to solve it successfully, it has also been essential to create a
submodel in each query to be able to reduce large inference networks to small graphs
with the information related to the consultation of the box that we want to consult in that
moment, that is, get rid of information not relevant to the current operation.
The implementation of the dimension with the se
allows, if you do not have absolute certainty about the existence of a pump in the
boxes that are being consulted, that our algorithm marks as a bomb or click
on that box if the probability values ​​are within that bound.
Without these improvements, the problem could not have been solved given its size and complexity.
To empirically verify everything described in this document, you can access the
Bayesian network repository [5] and run the Python files
nextStepMinesweeperSuggestor.py, which given a board size and a number of mines
solves the game step by step asking the user at all times for the
consent to take another step within the game, or the testRepeater.py file
  que ejecuta  el  algoritmo  que  contiene  la  red  de  inferencia bayesiana  que  hemos  
construido  de  forma  recursiva hasta  la  finalizacifin   de  todos   los  casos   de  prueba 
descritos anteriormente.


REFERENCIAS O I

1.     dugu    e100,   “A  python   Minesweeper   with   interfaces   for RL.,”  Github  
(https://Rithub.com duouvue 100/minesweeper), Diciembre 2016.
2.     “NumPy  - fundamental  package for scientific computing  with Python”, (http:  
www.numpv.ore)
3.     Cñdigo   decompilado   del   buscaminas   original   (http:// www.techuser.net/files 
code/minesweeper/stepsquare.asm)
4.     “Pgmpy       python   library   for   working   with   Probabilistic G rap  hi c a l   M o 
de ls ”,    (h t I p s:   / e it hu b . c o in  p e in pv / pairpy#instal1ation)
5.     M.A.  Antolin  y  D.  De  la  Torre,  “Sistema  de  resoluciân  del juego  El  Buscaminas  
mediante  el  uso  de  redes  bayesianas  ” G i t h  u b    ( h t t p s ’    / e i  t h u b    c o 
m / P a c o 1  i  v a / MincswccpcrBaycsianNctwork.eit), Junio 2018.
6.     Marta Vomlelova  y Jiri Vom1e1 “Applying  Bayesian  networks in   the   game   of   
Minesweeper”,   Czech   Republic   (http:// staff.utia.cas.cz/vomlel/vomlel-tichavsky-pem20l4.pdfl, 
2012
7.     J.L.  Ruiz  Reina,  F.J.  Martin  Mateos  et  al.  Redes  bayesianas. Dpto.  Ciencias  de  
la  Computacifin  e  Inteligencia  Artificial, Universidad  de Sevilla, 2017-2018